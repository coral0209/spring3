사용자 전체 리스트 개발 완료
사용자 페이징 처리
 
 페이징 처리를 위해 필요한 값
정렬기준 : order by id 
페이지 사이즈 - 
페이지

user/pagingUser => 페이지, 페이지 사이즈 파라미터를 보내지 않음
				페이지, 페이지 사이즈 파라미터가 없을 경우 servlet 기본값 처리를 함 . 



@RequestParam 
메소드 인자에서 사용가능한 어노테이션

1. 바인딩 될 파라미터 설정 (name) 
	파라미터 명과 메소드 인자 명이 다를 경우 자동 바인딩이 되지 않는 문제를 해결 
	파라미터명을 명시함으로써 메소드 인자에 자동 바인딩 될 수 있도록 설정
2. 파라미터가 존재하지 않을 경우 기본 값 설정(defaultValue) 
	파라미터가 존재하지 않을 경우, 메소드 인자를 primitive type 으로 선언한 경우 에러 발생 
	==> defaultValue 설정으로 에러 방지 가능
3. 파라미터 존재 여부 설정(required , 기본값은 true ) 
	파라미터가 반드시 필요한지 여부를 설정
	단 defaultValue 설정시 자동으로 false 로 설정됨 
	
	
@ModelAttribute : 사용빈도가 많지는 않다. 

1. 메소드
	@RequestMapping 어노테이션이 붙은 메소드가 실행되기 전에 먼저 실행되고 
	해당 메소드가 리넡하는 값을 Model 객체에 넣어준다. 
	
	//@RequestMapping 붙이지 않음
	@ModelAttribute
	public List<String> rangers(){
		.....
		return list; 
	}

	@RequestMapping("list")
	public String view(Model model){
		return "view"
	}
	
	
	localhost/user/list => rangers() 를 먼저 실행하고 model 에 자동으로 담긴다.  => list 
	localhost/user/list => rangers() 를 먼저 실행하고 model 에 자동으로 담긴다.  => list2
	
	
	@Before => @Test 와 비슷한 형식  
	 

2. 파라미터 인자
Model 객체에 저장된 속성을 파라미터 인자에 바인딩이 가능하다. 
command 객체의 경우 @ModelAttribute 어노테이션을 적용하지 않더라도 model 객체에 자동으로 등록이 된다.


3. sessionAttributes 
class 에 적용한다. 
@ModelAttribute 가 적용된 메소드가 @RequestMapping 이 적용된 메소드 실행전에 항상 호출 되는 부하를 줄이는
것이 목적이다. 
최초 1회에 대해서는 @ModelAttribute 가 적용된 메소드를 호출하여 해당 속성 값을 세션에 적용한다. 
그 이후 호출에 대해서는 세션에 저장된 값을 사용하여 @ModelAttribute 메서드가 적용된 로직이 반복 호출 되는 것을 방지한다. => 

미리 저장된 값을 보내준다.  => cache (오라클에서도 존재하는 기능이다.) => 반복적으로 콜해야해서 junit 에서는 힘들다. 


@SessionAttributes("rangers") -=> 최초 1번만 콜이 된다. 


@PathVariable : uri 의 일부를 method 인자로 바인딩 => 잘 기억하기 

(도서관 - 중앙도서관 / )

사용 : 메소드 인자
1. @RequestMapping uri path 설정시 어떤 부분을 가져올지 표현  
	==> @RequestMapping ("hello / {path]")
2. 메소드 인자에 @PathVariable 을 통해 가져올 값을 바인딩  
	public String view (@PathVariavle("path") String path ) {
	
	}



@RequestParam : 파라미터를 메소드 인자로 바인딩 할 때 
@RequestHeader 
=> header 정보를 메소드 인자로 바인딩 할때 

파일 업로드시 작업 내역  
1. 서블릿 
@RequestPart - 파일 업로드 : @RequestParam 과 유사 
Part part = request.getPart(); 	


1. 예전 서블릿 
	. form 태그 enctype = "multipart/form-data"
	. form 태그 method="post"
	. @MultipartConfig  
	파일정보 : header 정보 
2. Spring 에서 
	. form 태그 enctype = "multipart/form-data"
	. form 태그 method="post"
	. **** multipartResolver 라는 스프링 빈 등록이 필수야
	
	
	파일 정보 : MultipartFile 타입으로 
	
	Apache Commons FileUpload » 1.4 => pom 에 저장 
	multipartResolver 라는 스프링 빈 등록 CommonsMultipartResolver 

	부모 
	자식 (application- context.xml  => web.xml)
	
id 가 정해진 것 
conversionService 처럼 정해져 있다. 


=> @RequestPart - 파일 업로드 @RequestParam 과 유사 
복수 파라미터 전송 
메소드 인자로 List => x 안된다. List<String> 으로 할 수 없다.
메소드 인자로 배열 => o 된다. String[] 인자로 해야 한다.  
메소드 인자로 리스트를 필드로 하는 command 객체 ==> UsersVo userVo o 
public UsersVo {
	private List<String> userids ; 
	private List<String> usernms ; 
	
}

==> 이렇게 list 는 안되지만 list 를 감싸는 객체를 만들면 가능하긴 하다. 


스프링 MVC 실습 
1. 사용자 상세 페이지 (제외 사항 : 사용자 사진, 엑스 박스로 떠도 상관이 없다.)
2. 사용자 수정 페이지(파일 업로드까지 전체 이관) 
3. 사용자 등록 페이지(파일 업로드까지 전체 이관 ) 
4. 사용자 삭제 기능 (전체 이관)

5. 테스트 코드 작성  



